using Prometheus;

namespace YourApp.Api.Utils;


/// <summary>
/// Sample background service demonstrating how to publish metrics from background business logic.
/// </summary>
public sealed class SampleService : BackgroundService
{
    /// <summary>
    /// When we allocate HTTP clients, we mark them with this string to label the metrics generated by these HTTP clients.
    /// </summary>
    public const string HttpClientName = "SampleServiceHttpClient";
    private readonly ILogger<SampleService> _logger;

    private readonly IHttpClientFactory _httpClientFactory;
    public SampleService(IHttpClientFactory httpClientFactory, ILogger<SampleService> logger)
    {
        _httpClientFactory = httpClientFactory;
        _logger = logger;
    }



    private static readonly Counter ProcessedJobCount = Metrics
    .CreateCounter(
        "sample_jobs_processed_total",
        "Número total de jobs processados"
    );

    private static readonly Gauge JobsInProgress = Metrics
        .CreateGauge(
            "sample_jobs_in_progress",
            "Número de jobs sendo processados agora"
        );

    private static readonly Histogram JobDuration = Metrics
        .CreateHistogram(
            "sample_job_duration_seconds",
            "Duração dos jobs em segundos",
            new HistogramConfiguration
            {
                Buckets = Histogram.LinearBuckets(start: 1, width: 1, count: 10)
            }
        );


    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        _logger.LogInformation("SampleService iniciado");

        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                //  Incrementa gauge (job iniciou)
                JobsInProgress.Inc();

                //  Mede duração do job
                using (JobDuration.NewTimer())
                {
                    await ProcessJob(stoppingToken);
                }

                // Incrementa contador (job completou)
                ProcessedJobCount.Inc();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Erro ao processar job");
            }
            finally
            {
                // Decrementa gauge (job terminou)
                JobsInProgress.Dec();
            }

            // Aguarda antes do próximo ciclo
            await Task.Delay(TimeSpan.FromSeconds(5), stoppingToken);
        }
    }

    private async Task ProcessJob(CancellationToken cancellationToken)
    {
        // Cria HttpClient que já está instrumentado com métricas
        var httpClient = _httpClientFactory.CreateClient(HttpClientName);

        // Faz requisições (métricas são coletadas automaticamente)
        var response = await httpClient.GetAsync(
            "https://httpbin.org/delay/1",
            cancellationToken
        );

        _logger.LogInformation(
            "Request completado com status: {StatusCode}",
            response.StatusCode
        );

        // Simula processamento
        await Task.Delay(1000, cancellationToken);
    }

}